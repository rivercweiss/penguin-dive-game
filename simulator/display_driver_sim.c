#include "display_driver.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Desktop simulator version - stub implementation that maintains API compatibility

// Simple 8x8 font bitmap (basic characters 32-90 ' ' .. 'Z')
static const uint8_t font_8x8[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ' '
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // '!'
    {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // '"'
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}, // '#'
    {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00}, // '$'
    {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00}, // '%'
    {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00}, // '&'
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // '''
    {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00}, // '('
    {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00}, // ')'
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // '*'
    {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00}, // '+'
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x06, 0x00}, // ','
    {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00}, // '-'
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // '.'
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}, // '/'
    {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00}, // '0'
    {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00}, // '1'
    {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00}, // '2'
    {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00}, // '3'
    {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00}, // '4'
    {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00}, // '5'
    {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00}, // '6'
    {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00}, // '7'
    {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00}, // '8'
    {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00}, // '9'
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // ':'
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x06, 0x00}, // ';'
    {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00}, // '<'
    {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00}, // '='
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00}, // '>'
    {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00}, // '?'
    {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00}, // '@'
    {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00}, // 'A'
    {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00}, // 'B'
    {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00}, // 'C'
    {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00}, // 'D'
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00}, // 'E'
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00}, // 'F'
    {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00}, // 'G'
    {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00}, // 'H'
    {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 'I'
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00}, // 'J'
    {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00}, // 'K'
    {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00}, // 'L'
    {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00}, // 'M'
    {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00}, // 'N'
    {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00}, // 'O'
    {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00}, // 'P'
    {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00}, // 'Q'
    {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00}, // 'R'
    {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00}, // 'S'
    {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 'T'
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00}, // 'U'
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // 'V'
    {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // 'W'
    {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00}, // 'X'
    {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00}, // 'Y'
    {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00}, // 'Z'
};

bool display_driver_init(display_context_t *ctx) {
    if (!ctx) {
        printf("Invalid display context\n");
        return false;
    }

    printf("Initializing desktop simulator display driver\n");

    // Allocate frame buffer
    size_t buffer_size = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
    ctx->front_buffer = malloc(buffer_size);
    ctx->back_buffer = malloc(buffer_size);

    if (!ctx->front_buffer || !ctx->back_buffer) {
        printf("Failed to allocate display buffers\n");
        if (ctx->front_buffer) free(ctx->front_buffer);
        if (ctx->back_buffer) free(ctx->back_buffer);
        return false;
    }

    // Initialize buffers to black
    memset(ctx->front_buffer, 0, buffer_size);
    memset(ctx->back_buffer, 0, buffer_size);
    ctx->current_buffer = ctx->back_buffer;

    ctx->initialized = true;
    printf("Desktop simulator display driver initialized successfully\n");
    return true;
}

void display_driver_deinit(display_context_t *ctx) {
    if (!ctx || !ctx->initialized) {
        return;
    }

    // Free buffers
    if (ctx->front_buffer) {
        free(ctx->front_buffer);
        ctx->front_buffer = NULL;
    }
    if (ctx->back_buffer) {
        free(ctx->back_buffer);
        ctx->back_buffer = NULL;
    }

    ctx->initialized = false;
    printf("Desktop simulator display driver deinitialized\n");
}

void display_driver_clear_screen(display_context_t *ctx, uint16_t color) {
    if (!ctx || !ctx->initialized || !ctx->current_buffer) {
        return;
    }

    uint16_t *buffer = (uint16_t *)ctx->current_buffer;
    uint32_t pixel_count = DISPLAY_WIDTH * DISPLAY_HEIGHT;
    for (uint32_t i = 0; i < pixel_count; i++) {
        buffer[i] = color;
    }
}

void display_driver_draw_rectangle(display_context_t *ctx, int x, int y, int width, int height, uint16_t color) {
    if (!ctx || !ctx->initialized || !ctx->current_buffer) {
        return;
    }

    // Clip rectangle to screen boundaries
    if (x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT) return;
    if (x + width < 0 || y + height < 0) return;

    int x_start = (x < 0) ? 0 : x;
    int y_start = (y < 0) ? 0 : y;
    int x_end = (x + width > DISPLAY_WIDTH) ? DISPLAY_WIDTH : x + width;
    int y_end = (y + height > DISPLAY_HEIGHT) ? DISPLAY_HEIGHT : y + height;

    uint16_t *buffer = (uint16_t *)ctx->current_buffer;
    
    // Draw rectangle
    for (int row = y_start; row < y_end; row++) {
        for (int col = x_start; col < x_end; col++) {
            buffer[row * DISPLAY_WIDTH + col] = color;
        }
    }
}

void display_driver_draw_text(display_context_t *ctx, int x, int y, const char *text, uint16_t color) {
    if (!ctx || !ctx->initialized || !ctx->current_buffer || !text) {
        return;
    }

    uint16_t *buffer = (uint16_t *)ctx->current_buffer;
    int cursor_x = x;
    int cursor_y = y;

    while (*text) {
        char ch = *text;
        
        // Normalize to our limited font set
        if (ch >= 'a' && ch <= 'z') {
            ch = (char)(ch - 32); // map to 'A'..'Z'
        }
        
        // Handle newline
        if (ch == '\n') {
            cursor_x = x;
            cursor_y += 8;
            text++;
            continue;
        }

        // Check if character is in our font range (32..90)
        if (ch >= 32 && ch <= 90) {
            const uint8_t *glyph = font_8x8[ch - 32];
            
            // Draw 8x8 character
            for (int row = 0; row < 8; row++) {
                if (cursor_y + row >= DISPLAY_HEIGHT) break;
                if (cursor_y + row < 0) continue;
                
                uint8_t row_data = glyph[row];
                for (int col = 0; col < 8; col++) {
                    if (cursor_x + col >= DISPLAY_WIDTH) break;
                    if (cursor_x + col < 0) continue;
                    
                    // Font data uses LSB-as-left orientation
                    if (row_data & (1 << col)) {
                        buffer[(cursor_y + row) * DISPLAY_WIDTH + (cursor_x + col)] = color;
                    }
                }
            }
        }
        
        cursor_x += 8; // Move to next character position
        text++;
    }
}

void display_driver_swap_buffers(display_context_t *ctx) {
    if (!ctx || !ctx->initialized) {
        return;
    }

    // Swap front and back buffers
    void *temp = ctx->front_buffer;
    ctx->front_buffer = ctx->back_buffer;
    ctx->back_buffer = temp;
    ctx->current_buffer = ctx->back_buffer;
}

void display_driver_flush(display_context_t *ctx) {
    if (!ctx || !ctx->initialized || !ctx->front_buffer) {
        return;
    }

    // For desktop simulator, this is a no-op
    // The actual rendering to SDL is handled by the simulator main loop
}

void display_driver_task_handler(void) {
    // For desktop simulator, this is a no-op
    // No LVGL task handling needed
}

uint16_t display_driver_get_pixel(display_context_t *ctx, int x, int y) {
    if (!ctx || !ctx->initialized || !ctx->front_buffer) {
        return 0;
    }
    
    // Check bounds
    if (x < 0 || x >= DISPLAY_WIDTH || y < 0 || y >= DISPLAY_HEIGHT) {
        return 0;
    }
    
    uint16_t *buffer = (uint16_t *)ctx->front_buffer;
    return buffer[y * DISPLAY_WIDTH + x];
}