#include "display_driver.h"
#include <stdlib.h>
#include <string.h>

bool display_driver_init(display_context_t* ctx) {
    if (!ctx) return false;
    
    memset(ctx, 0, sizeof(display_context_t));
    
    ctx->width = DISPLAY_WIDTH;
    ctx->height = DISPLAY_HEIGHT;
    
    // Allocate framebuffer
    size_t buffer_size = ctx->width * ctx->height * sizeof(uint16_t);
    ctx->framebuffer = malloc(buffer_size);
    if (!ctx->framebuffer) {
        return false;
    }
    
    // Allocate back buffer for double buffering
    ctx->back_buffer = malloc(buffer_size);
    if (!ctx->back_buffer) {
        free(ctx->framebuffer);
        ctx->framebuffer = NULL;
        return false;
    }
    
    ctx->double_buffered = true;
    
    // Clear both buffers
    memset(ctx->framebuffer, 0, buffer_size);
    memset(ctx->back_buffer, 0, buffer_size);
    
    ctx->initialized = true;
    return true;
}

void display_driver_deinit(display_context_t* ctx) {
    if (!ctx) return;
    
    if (ctx->framebuffer) {
        free(ctx->framebuffer);
        ctx->framebuffer = NULL;
    }
    
    if (ctx->back_buffer) {
        free(ctx->back_buffer);
        ctx->back_buffer = NULL;
    }
    
    ctx->initialized = false;
}

void display_driver_clear_screen(display_context_t* ctx, display_color_t color) {
    if (!ctx || !ctx->initialized || !ctx->back_buffer) return;
    
    uint16_t* buffer = ctx->back_buffer;
    size_t pixel_count = ctx->width * ctx->height;
    
    for (size_t i = 0; i < pixel_count; i++) {
        buffer[i] = color;
    }
    
    // Also clear the front buffer to ensure consistency
    if (ctx->framebuffer) {
        uint16_t* front_buffer = ctx->framebuffer;
        for (size_t i = 0; i < pixel_count; i++) {
            front_buffer[i] = color;
        }
    }
}

void display_driver_draw_rectangle(display_context_t* ctx, int x, int y, int width, int height, display_color_t color) {
    if (!ctx || !ctx->initialized || !ctx->back_buffer) return;
    
    // Clamp to screen bounds
    if (x < 0) {
        width += x;
        x = 0;
    }
    if (y < 0) {
        height += y;
        y = 0;
    }
    if (x + width > ctx->width) {
        width = ctx->width - x;
    }
    if (y + height > ctx->height) {
        height = ctx->height - y;
    }
    
    if (width <= 0 || height <= 0) return;
    
    uint16_t* buffer = ctx->back_buffer;
    
    // Ensure row-major order: buffer[y * width + x]
    for (int row = y; row < y + height; row++) {
        for (int col = x; col < x + width; col++) {
            int index = row * ctx->width + col;
            if (index >= 0 && index < ctx->width * ctx->height) {
                buffer[index] = color;
            }
        }
    }
}

void display_driver_draw_sprite(display_context_t* ctx, sprite_t* sprite) {
    if (!sprite) return;
    
    display_driver_draw_rectangle(ctx, sprite->x, sprite->y, sprite->width, sprite->height, sprite->color);
}

// Optimized 5x7 bitmap font for better readability on low pixel count displays
static const uint8_t font_bitmaps[][7] = {
    // Space (ASCII 32)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ! (ASCII 33)
    {0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00},
    // " (ASCII 34)
    {0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00},
    // # (ASCII 35)
    {0x28, 0x7C, 0x28, 0x7C, 0x28, 0x00, 0x00},
    // $ (ASCII 36)
    {0x10, 0x3C, 0x50, 0x38, 0x14, 0x78, 0x10},
    // % (ASCII 37)
    {0x60, 0x64, 0x08, 0x10, 0x26, 0x06, 0x00},
    // & (ASCII 38)
    {0x30, 0x48, 0x30, 0x4A, 0x44, 0x3A, 0x00},
    // ' (ASCII 39)
    {0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ( (ASCII 40)
    {0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08},
    // ) (ASCII 41)
    {0x20, 0x10, 0x08, 0x08, 0x08, 0x10, 0x20},
    // * (ASCII 42)
    {0x10, 0x54, 0x38, 0x7C, 0x38, 0x54, 0x10},
    // + (ASCII 43)
    {0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00},
    // , (ASCII 44)
    {0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20},
    // - (ASCII 45)
    {0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00},
    // . (ASCII 46)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00},
    // / (ASCII 47)
    {0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00},
    // 0 (ASCII 48)
    {0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38},
    // 1 (ASCII 49)
    {0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x38},
    // 2 (ASCII 50)
    {0x38, 0x44, 0x04, 0x08, 0x10, 0x20, 0x7C},
    // 3 (ASCII 51)
    {0x38, 0x44, 0x04, 0x18, 0x04, 0x44, 0x38},
    // 4 (ASCII 52)
    {0x08, 0x18, 0x28, 0x48, 0x7C, 0x08, 0x08},
    // 5 (ASCII 53)
    {0x7C, 0x40, 0x78, 0x04, 0x04, 0x44, 0x38},
    // 6 (ASCII 54)
    {0x18, 0x20, 0x40, 0x78, 0x44, 0x44, 0x38},
    // 7 (ASCII 55)
    {0x7C, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10},
    // 8 (ASCII 56)
    {0x38, 0x44, 0x44, 0x38, 0x44, 0x44, 0x38},
    // 9 (ASCII 57)
    {0x38, 0x44, 0x44, 0x3C, 0x04, 0x08, 0x30},
    // : (ASCII 58)
    {0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00},
    // ; (ASCII 59)
    {0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x20},
    // < (ASCII 60)
    {0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08},
    // = (ASCII 61)
    {0x00, 0x00, 0x7C, 0x00, 0x7C, 0x00, 0x00},
    // > (ASCII 62)
    {0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20},
    // ? (ASCII 63)
    {0x38, 0x44, 0x04, 0x08, 0x10, 0x00, 0x10},
    // @ (ASCII 64)
    {0x38, 0x44, 0x5C, 0x54, 0x5C, 0x40, 0x38},
    // A (ASCII 65)
    {0x38, 0x44, 0x44, 0x7C, 0x44, 0x44, 0x44},
    // B (ASCII 66)
    {0x78, 0x44, 0x44, 0x78, 0x44, 0x44, 0x78},
    // C (ASCII 67)
    {0x38, 0x44, 0x40, 0x40, 0x40, 0x44, 0x38},
    // D (ASCII 68)
    {0x78, 0x44, 0x44, 0x44, 0x44, 0x44, 0x78},
    // E (ASCII 69)
    {0x7C, 0x40, 0x40, 0x78, 0x40, 0x40, 0x7C},
    // F (ASCII 70)
    {0x7C, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40},
    // G (ASCII 71)
    {0x38, 0x44, 0x40, 0x5C, 0x44, 0x44, 0x38},
    // H (ASCII 72)
    {0x44, 0x44, 0x44, 0x7C, 0x44, 0x44, 0x44},
    // I (ASCII 73)
    {0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38},
    // J (ASCII 74)
    {0x1C, 0x08, 0x08, 0x08, 0x08, 0x48, 0x30},
    // K (ASCII 75)
    {0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44},
    // L (ASCII 76)
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7C},
    // M (ASCII 77)
    {0x44, 0x6C, 0x54, 0x44, 0x44, 0x44, 0x44},
    // N (ASCII 78)
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x44, 0x44},
    // O (ASCII 79)
    {0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38},
    // P (ASCII 80)
    {0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x40},
    // Q (ASCII 81)
    {0x38, 0x44, 0x44, 0x44, 0x54, 0x48, 0x34},
    // R (ASCII 82)
    {0x78, 0x44, 0x44, 0x78, 0x50, 0x48, 0x44},
    // S (ASCII 83)
    {0x38, 0x44, 0x40, 0x38, 0x04, 0x44, 0x38},
    // T (ASCII 84)
    {0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10},
    // U (ASCII 85)
    {0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38},
    // V (ASCII 86)
    {0x44, 0x44, 0x44, 0x44, 0x28, 0x28, 0x10},
    // W (ASCII 87)
    {0x44, 0x44, 0x44, 0x54, 0x6C, 0x44, 0x44},
    // X (ASCII 88)
    {0x44, 0x28, 0x10, 0x10, 0x10, 0x28, 0x44},
    // Y (ASCII 89)
    {0x44, 0x28, 0x28, 0x10, 0x10, 0x10, 0x10},
    // Z (ASCII 90)
    {0x7C, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7C},
    // [ (ASCII 91)
    {0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38},
    // \ (ASCII 92)
    {0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00},
    // ] (ASCII 93)
    {0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38},
    // ^ (ASCII 94)
    {0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00},
    // _ (ASCII 95)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C},
    // ` (ASCII 96)
    {0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00},
    // a (ASCII 97)
    {0x00, 0x00, 0x38, 0x04, 0x3C, 0x44, 0x3C},
    // b (ASCII 98)
    {0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x78},
    // c (ASCII 99)
    {0x00, 0x00, 0x38, 0x44, 0x40, 0x44, 0x38},
    // d (ASCII 100)
    {0x04, 0x04, 0x3C, 0x44, 0x44, 0x44, 0x3C},
    // e (ASCII 101)
    {0x00, 0x00, 0x38, 0x44, 0x7C, 0x40, 0x38},
    // f (ASCII 102)
    {0x18, 0x24, 0x20, 0x70, 0x20, 0x20, 0x20},
    // g (ASCII 103)
    {0x3C, 0x44, 0x44, 0x3C, 0x04, 0x44, 0x38},
    // h (ASCII 104)
    {0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x44},
    // i (ASCII 105)
    {0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x38},
    // j (ASCII 106)
    {0x08, 0x00, 0x18, 0x08, 0x08, 0x48, 0x30},
    // k (ASCII 107)
    {0x40, 0x40, 0x44, 0x48, 0x70, 0x48, 0x44},
    // l (ASCII 108)
    {0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38},
    // m (ASCII 109)
    {0x00, 0x00, 0x6C, 0x54, 0x54, 0x54, 0x54},
    // n (ASCII 110)
    {0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44},
    // o (ASCII 111)
    {0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38},
    // p (ASCII 112)
    {0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x40},
    // q (ASCII 113)
    {0x3C, 0x44, 0x44, 0x3C, 0x04, 0x04, 0x04},
    // r (ASCII 114)
    {0x00, 0x00, 0x58, 0x64, 0x40, 0x40, 0x40},
    // s (ASCII 115)
    {0x00, 0x00, 0x3C, 0x40, 0x38, 0x04, 0x78},
    // t (ASCII 116)
    {0x20, 0x20, 0x70, 0x20, 0x20, 0x24, 0x18},
    // u (ASCII 117)
    {0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x3C},
    // v (ASCII 118)
    {0x00, 0x00, 0x44, 0x44, 0x28, 0x28, 0x10},
    // w (ASCII 119)
    {0x00, 0x00, 0x44, 0x54, 0x54, 0x6C, 0x44},
    // x (ASCII 120)
    {0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44},
    // y (ASCII 121)
    {0x00, 0x00, 0x44, 0x44, 0x3C, 0x04, 0x38},
    // z (ASCII 122)
    {0x00, 0x00, 0x7C, 0x08, 0x10, 0x20, 0x7C},
    // { (ASCII 123)
    {0x18, 0x10, 0x10, 0x20, 0x10, 0x10, 0x18},
    // | (ASCII 124)
    {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10},
    // } (ASCII 125)
    {0x30, 0x10, 0x10, 0x08, 0x10, 0x10, 0x30},
    // ~ (ASCII 126)
    {0x00, 0x20, 0x54, 0x08, 0x00, 0x00, 0x00}
};

void display_driver_draw_text(display_context_t* ctx, int x, int y, const char* text, display_color_t color) {
    if (!ctx || !ctx->initialized || !text) return;
    
    const int char_width = 5;
    const int char_height = 7;
    
    int current_x = x;
    int current_y = y;
    
    while (*text) {
        if (*text == '\n') {
            current_x = x;
            current_y += char_height + 1;
        } else if (*text >= 32 && *text <= 126) {
            // Get the bitmap for this character
            const uint8_t* bitmap = font_bitmaps[*text - 32];
            
            // Draw the character pixel by pixel
            for (int row = 0; row < char_height; row++) {
                uint8_t row_data = bitmap[row];
                for (int col = 0; col < char_width; col++) {
                    if (row_data & (0x40 >> col)) {
                        display_driver_set_pixel(ctx, current_x + col, current_y + row, color);
                    }
                }
            }
            current_x += char_width + 1;
        }
        text++;
    }
}

void display_driver_swap_buffers(display_context_t* ctx) {
    if (!ctx || !ctx->initialized || !ctx->framebuffer || !ctx->back_buffer) return;
    
    // Swap the buffers
    uint16_t* temp = ctx->framebuffer;
    ctx->framebuffer = ctx->back_buffer;
    ctx->back_buffer = temp;
}

void display_driver_flush(display_context_t* ctx) {
    if (!ctx || !ctx->initialized) return;
    
    // In a real implementation, this would send the framebuffer to the physical display
    // For testing purposes, this is a no-op
}

uint16_t display_driver_get_pixel(display_context_t* ctx, int x, int y) {
    if (!ctx || !ctx->initialized || !ctx->framebuffer) return 0;
    
    if (x < 0 || x >= ctx->width || y < 0 || y >= ctx->height) {
        return 0;
    }
    
    int index = y * ctx->width + x;
    if (index >= 0 && index < ctx->width * ctx->height) {
        return ctx->framebuffer[index];
    }
    return 0;
}

void display_driver_set_pixel(display_context_t* ctx, int x, int y, display_color_t color) {
    if (!ctx || !ctx->initialized || !ctx->back_buffer) return;
    
    if (x < 0 || x >= ctx->width || y < 0 || y >= ctx->height) {
        return;
    }
    
    int index = y * ctx->width + x;
    if (index >= 0 && index < ctx->width * ctx->height) {
        ctx->back_buffer[index] = color;
    }
}

bool display_driver_is_initialized(display_context_t* ctx) {
    if (!ctx) return false;
    return ctx->initialized && ctx->framebuffer && ctx->back_buffer;
}